# Документация по проекту: Система управления беспилотными такси

## 1. Краткое описание проекта

Проект моделирует работу системы управления парком беспилотных такси в городе в многопоточном режиме.  
Все приложение — это симуляция: клиенты генерируются автоматически, диспетчер распределяет заказы по такси, такси “ездят” и выполняют заказы.

Результат работы — логи и статистика по системе:

- сколько заказов выполнено;
- среднее время ожидания;
- загрузка такси;
- общий пробег и выручка и т.д.

Этот документ нужен, чтобы быстро войти в курс дела по проекту: понять исходное задание, дополнительные улучшения, структуру проекта и поэтапный план реализации.

---

## 2. Исходное задание (анализ требований)

**Тема:** Система управления беспилотными такси в городе (вариант 2).

### 2.1. Состав системы

1. **Такси** (каждое такси — отдельный поток):
   - Работает независимо.
   - Ждёт назначения заказа.
   - После назначения:
     - “едет” к клиенту (задержка);
     - “перевозит” клиента к точке назначения (задержка зависит от расстояния);
     - возвращается в состояние “свободен”.
   - По завершении поездки сообщает диспетчеру.

2. **Диспетчер**:
   - Мониторит очередь клиентских заказов.
   - Выбирает подходящее свободное такси (например, ближайшее).
   - Назначает заказ выбранному такси.
   - Получает уведомления о завершении поездок.

3. **Генератор клиентов**:
   - Порождает клиентские запросы.
   - Каждый запрос содержит:
     - координаты отправления;
     - координаты назначения;
     - время создания (`timestamp`).
   - Помещает запросы в потокобезопасную очередь заказов.

4. **Очередь заказов**:
   - Потокобезопасная `BlockingQueue<RideRequest>`.
   - Используется для связи между генератором клиентов и диспетчером.

### 2.2. Многопоточность и синхронизация

- Такси — отдельные потоки.
- Диспетчер — отдельный поток.
- Генератор клиентов — отдельный поток.
- Доступ к состоянию такси должен быть потокобезопасным.
- При выборе такси не должно быть гонок данных.
- Разрешено использовать:
  - `ReentrantLock`
  - `synchronized`
  - атомарные типы (`Atomic*`)
  - коллекции из `java.util.concurrent` (в т.ч. `BlockingQueue`).

### 2.3. Критерии успешности

- Очередь заказов не теряет данные.
- Такси обслуживают заказы без ошибок и взаимных блокировок (deadlock’ов).
- Логи отражают все ключевые события:
  - создание заказа;
  - назначение такси;
  - начало поездки;
  - завершение поездки.

---

## 3. Дополнительные улучшения (для оценки “10”)

Поверх базовых требований планируется реализовать следующие улучшения.

### 3.1. Архитектура по слоям (model / service / infra / app)

Структурировать проект по слоям:

- **model** — сущности предметной области (данные): координаты, заявки, статусы, типы такси.
- **service** — доменная логика:
  - диспетчер как сервис;
  - стратегии назначения заказов;
  - логика работы такси (активные объекты/worker’ы).
- **infra** — инфраструктура и симуляция:
  - генератор запросов;
  - запуск и остановка потоков;
  - конфигурация симуляции.
- **app** — точка входа (`main`), чтение настроек, запуск симуляции.

Это делает проект более читаемым, расширяемым и “похожим на реальное приложение”.

### 3.2. Разные стратегии распределения заказов

Ввести интерфейс стратегии и несколько реализаций:

- `NearestTaxiStrategy`:
  - выбирает ближайшее свободное такси по расстоянию до точки посадки.
- `LeastLoadedTaxiStrategy`:
  - выбирает свободное такси с наименьшим количеством выполненных заказов (баланс нагрузки).

Стратегия выбирается через конфигурацию (например, параметр при запуске).

### 3.3. Типы такси и тарифы

Добавить разные классы такси:

- `TaxiType` (enum), например: `ECONOMY`, `COMFORT`, `BUSINESS`.

У каждого типа:

- базовая стоимость (`baseFare`);
- стоимость за единицу расстояния (`perKmRate`).

У запроса (`RideRequest`):

- поле `requestedType` — желаемый класс такси.

Диспетчер:

- при выборе такси учитывает тип (заказ `ECONOMY` → эконом/выше, и т.п. при желании).

Каждая поездка:

- имеет стоимость, рассчитываемую через `FareCalculator`.

### 3.4. Сбор и вывод статистики

Собирать статистику по всей симуляции:

- Общее количество выполненных заказов.
- Среднее время ожидания клиента (от создания заказа до начала поездки).
- Среднее время поездки.
- Общий пробег всех такси.
- Общая выручка.
- Статистика по каждому такси:
  - количество выполненных заказов;
  - суммарный пробег;
  - суммарная выручка.

В конце симуляции выводится сводный отчёт.

### 3.5. Параметризуемая симуляция и корректное завершение

Сделать симуляцию настраиваемой:

- количество такси;
- длительность симуляции (в секундах);
- средний интервал между новыми запросами;
- стратегия диспетчера.

По истечении заданного времени:

- аккуратно останавливать генератор, диспетчер и все такси;
- дожидаться завершения потоков;
- выводить статистику.

---

## 4. Структура проекта

Базовый пакет можно назвать, например, `ru.mystudent.taxi` (здесь и далее можно заменить `mystudent` на своё имя/ник).

### 4.1. Общая структура директорий

```text
taxi-simulation/
  src/
    main/
      java/
        ru/
          mystudent/
            taxi/
              app/
              model/
              service/
              infra/
              stats/
              util/
  .gitignore
  (опционально: pom.xml или build.gradle)
```

### 4.2. Пакет `app` — точка входа
**`ru.mystudent.taxi.app`**

**`Main.java`**
*   Читает аргументы командной строки (или через консоль).
*   Формирует `SimulationConfig`.
*   Создаёт `SimulationRunner`.
*   Запускает симуляцию.
*   По завершении — вызывает вывод статистики.

### 4.3. Пакет `model` — модель предметной области
**`ru.mystudent.taxi.model`**

**`Point`**
*   `double x, y`
*   `double distanceTo(Point other)`

**`TaxiType` (enum)**
*   Варианты: `ECONOMY`, `COMFORT`, `BUSINESS`.
*   Поля:
    *   `double baseFare`
    *   `double perKmRate`

**`RideStatus` (enum)**
*   `NEW`, `ASSIGNED`, `IN_PROGRESS`, `COMPLETED`.

**`TaxiStatus` (enum)**
*   `IDLE`, `TO_PICKUP`, `WITH_PASSENGER`.

**`RideRequest`**
*   `long id`
*   `Point pickup`
*   `Point dropoff`
*   `long createdAtMillis`
*   `TaxiType requestedType`
*   (опционально) `RideStatus status`, `Long assignedTaxiId`.
    *   _(Опционально)_

**`TaxiSnapshot`**
*   "Снимок" состояния такси для статистики/UI.

### 4.4. Пакет `service` — бизнес-логика
**`ru.mystudent.taxi.service`**

**Интерфейсы:**
*   **`DispatchStrategy`**
    *   `TaxiWorker selectTaxi(List<TaxiWorker> taxis, RideRequest request);`
    *   `String getName();`
*   **`DispatcherCallback`**
    *   `void onRideCompleted(TaxiWorker taxi, RideRequest ride, double distance, double fare, long waitTimeMillis);`

**Реализации стратегий:**
*   **`NearestTaxiStrategy`**
    *   Среди свободных такси выбирает ближайшее к `pickupLocation` заказа.
*   **`LeastLoadedTaxiStrategy`**
    *   Среди свободных такси выбирает то, у которого меньше всего `completedRides`.

**Основные сервисы:**

**`TaxiWorker implements Runnable`**
*   **Поля:**
    *   идентификатор такси;
    *   тип такси (`TaxiType`);
    *   текущая позиция (`Point`);
    *   статус (`TaxiStatus`);
    *   своя `BlockingQueue<RideRequest>` для назначенных заказов;
    *   ссылка на `DispatcherCallback` (для уведомления о завершении).
*   **Логика в `run()`:**
    *   в цикле брать заказ из личной очереди;
    *   "ехать" к клиенту (`sleep` в зависимости от расстояния);
    *   "везти" клиента (ещё один `sleep`);
    *   обновлять позицию и статус;
    *   считать пройденное расстояние;
    *   уведомлять диспетчер/статистику через callback.

**`Dispatcher implements Runnable, DispatcherCallback`**
*   **Поля:**
    *   `BlockingQueue<RideRequest> requestQueue;`
    *   `List<TaxiWorker> taxis;`
    *   `DispatchStrategy strategy;`
    *   ссылка на `StatisticsCollector` (из `stats`);
    *   флаг `volatile boolean running;`
    *   механизм синхронизации для выбора такси (например, `ReentrantLock` или `synchronized`).
*   **Логика в `run()`:**
    *   в цикле, пока `running`:
        *   забирать заказы из общей очереди;
        *   выбирать подходящее свободное такси с помощью `DispatchStrategy`;
        *   помечать такси занятым;
        *   помещать заказ в его личную очередь.
*   **Реализация `onRideCompleted(...)`:**
    *   обновление статуса такси на `IDLE`;
    *   передача данных в `StatisticsCollector`.

### 4.5. Пакет `infra` — инфраструктура и симуляция
**`ru.mystudent.taxi.infra`**

**`SimulationConfig`**
*   `int numberOfTaxis`
*   `int simulationDurationSeconds`
*   `long meanRequestIntervalMillis`
*   `String strategyName` или `enum StrategyType`
*   параметры скорости/задержек (при необходимости)

**`RequestGenerator implements Runnable`**
*   **Поля:**
    *   `BlockingQueue<RideRequest> requestQueue;`
    *   `SimulationConfig config;`
    *   генератор ID (`AtomicLong`).
    *   флаг `volatile boolean running`.
*   **Логика:**
    *   пока `running`:
        *   генерировать координаты (`pickup`, `dropoff`) и тип такси;
        *   создавать `RideRequest` и класть в очередь;
        *   спать случайное время вокруг `meanRequestIntervalMillis`.

**`SimulationRunner`**
*   Отвечает за:
    *   создание всех компонентов;
    *   запуск потоков;
    *   ожидание заданного времени;
    *   остановку всех потоков;
    *   вывод статистики.
*   **Примерный план внутри:**
    1.  Создать `BlockingQueue<RideRequest>`.
    2.  Создать `StatisticsCollector`.
    3.  Создать список `TaxiWorker`ов.
    4.  Создать выбранную `DispatchStrategy`.
    5.  Создать `Dispatcher` и `RequestGenerator`.
    6.  Запустить потоки такси, диспетчера, генератора.
    7.  `Thread.sleep(simulationDurationSeconds * 1000);`
    8.  Остановить:
        *   `running = false` у генератора и диспетчера;
        *   отправить "poison pill" в очереди такси или корректно завершить ожидание;
        *   `join()` всех потоков.
    9.  Вызвать `StatisticsCollector.printSummary()`.

### 4.6. Пакет `stats` — статистика
**`ru.mystudent.taxi.stats`**

**`StatisticsCollector`**
*   **Поля** (потокобезопасные, через `Atomic*` или `synchronized`):
    *   общее число завершённых поездок;
    *   суммарное время ожидания;
    *   суммарное время поездки;
    *   суммарное расстояние;
    *   общая выручка;
    *   `Map<Long, TaxiStats>` — статистика по каждому такси.
*   **Методы:**
    *   `recordCompletedRide(taxiId, waitTimeMillis, rideTimeMillis, distance, fare);`
    *   геттеры агрегированных значений;
    *   `printSummary()` — выводит сводный отчёт.

**`TaxiStats`**
*   **Поля:**
    *   `int completedRides`
    *   `double totalDistance`
    *   `double totalRevenue`
*   Методы обновления (потокобезопасные).

### 4.7. Пакет `util` — вспомогательные классы
**`ru.mystudent.taxi.util`**

**`FareCalculator`**
*   Метод, считающий стоимость поездки по типу такси, расстоянию и тарифам.

**`RandomUtils`**
*   Генерация координат в заданном диапазоне.
*   Генерация случайного интервала вокруг среднего.

**`ArgsParser` (опционально)**
*   Парсит аргументы командной строки в `SimulationConfig` (или часть параметров).

---

## 5. Пошаговый план реализации
**Шаг 1. Создание проекта и пакетов**
1.  Создать Java-проект (через IDE или вручную).
2.  Определить корневой пакет, например `ru.mystudent.taxi`.
3.  Создать пакеты:
    *   `app`
    *   `model`
    *   `service`
    *   `infra`
    *   `stats`
    *   `util`.

**Шаг 2. Базовая модель (`model`)**
1.  Реализовать:
    *   `Point` c методом `distanceTo`.
    *   `TaxiType` с тарифами.
    *   `RideStatus`.
    *   `TaxiStatus`.
    *   `RideRequest` (поля, конструктор, геттеры/сеттеры).
2.  Пока без сложной логики, только данные.

**Шаг 3. Скелет сервисов (`service`) — без реализации**
1.  Создать интерфейсы:
    *   `DispatchStrategy` (методы без тела).
    *   `DispatcherCallback`.
2.  Создать классы:
    *   `TaxiWorker` (пока просто поля, `implements Runnable`, но без логики `run()`).
    *   `Dispatcher` (`implements Runnable`, скелет).

**Шаг 4. Конфигурация и инфраструктура (`infra`)**
1.  Реализовать `SimulationConfig` с полями и конструкторами.
2.  Создать `RequestGenerator` (пока только структура класса).
3.  Создать `SimulationRunner` с пустыми методами `runSimulation()` или аналогичным.

**Шаг 5. Простая реализация такси и генератора**
1.  В `TaxiWorker.run()`:
    *   Бесконечный цикл с чтением из своей `BlockingQueue<RideRequest>`.
    *   Логи типа "получил заказ", "еду к клиенту", "везу клиента".
2.  В `RequestGenerator.run()`:
    *   Генерация заказов и помещение в общую `BlockingQueue`.
3.  **Проверка:**
    *   можно пока без диспетчера вручную класть заказы в очереди такси и смотреть на логи.

**Шаг 6. Реализация диспетчера и первой стратегии**
1.  Реализовать `NearestTaxiStrategy`:
    *   среди свободных такси выбрать ближайшее по расстоянию до `pickup`.
2.  В `Dispatcher.run()`:
    *   забирать заказы из общей очереди;
    *   выбирать такси через стратегию;
    *   помечать такси занятым;
    *   класть заказ в его личную очередь.
3.  Связать `TaxiWorker` и `DispatcherCallback` (уведомление о завершении).

**Шаг 7. Вторая стратегия и выбор стратегии**
1.  Реализовать `LeastLoadedTaxiStrategy`.
2.  В `SimulationConfig` добавить поле для выбора стратегии.
3.  В `SimulationRunner` — по конфигурации создавать нужную стратегию.

**Шаг 8. Статистика**
1.  Реализовать `StatisticsCollector` и `TaxiStats`.
2.  В `Dispatcher.onRideCompleted()`:
    *   считать время ожидания, время поездки, расстояние, стоимость.
    *   вызывать `stats.recordCompletedRide(...)`.
3.  Написать `printSummary()` для вывода отчёта по окончании симуляции.

**Шаг 9. Корректный запуск и остановка (`SimulationRunner` + `Main`)**
В `SimulationRunner`:
1.  создать все компоненты;
2.  запустить потоки;
3.  `sleep` на время симуляции;
4.  остановить все потоки:
    *   `running = false` в генераторе и диспетчере;
    *   отправить "poison pill" или другой сигнал такси;
    *   `join()` потоков.
5.  вызвать `stats.printSummary()`.
В `Main`:
1.  разобрать аргументы (или запросить ввод через консоль);
2.  создать `SimulationConfig`;
3.  создать и запустить `SimulationRunner`.

**Шаг 10. Доработка логирования и полировка**
1.  Привести логи к понятному формату:
    *   указывать `id` заказа, `id` такси, координаты, время.
2.  Проверить:
    *   нет ли гонок (где надо — добавить `synchronized`/`Lock`/атомарные поля);
    *   нет ли взаимных блокировок;
    *   корректно ли завершаются потоки.
3.  При необходимости — добавить комментарии в код для защиты.
